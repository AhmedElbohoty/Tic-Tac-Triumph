<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic Tac Triumph</title>
    <style>
        /* Basic styling for the body and elements */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #ff9a9e 0%, #fad0c4 99%, #fad0c4 100%);
        }

        h1 {
            color: #fff;
            text-shadow: 2px 2px 4px #000;
        }

        #gameCanvas {
            border: 5px solid #fff;
            background-color: #ffeb3b;
            width: 80vmin;
            height: 80vmin;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            transition: transform 0.3s;
        }

        #gameCanvas:hover {
            transform: scale(1.05);
        }

        #restartButton {
            display: none;
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 1rem;
            background-color: #ff4081;
            color: #fff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s, transform 0.3s;
        }

        #restartButton:hover {
            background-color: #f50057;
            transform: scale(1.1);
        }

        #scoreboard {
            margin-top: 20px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 2px solid #fff;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            font-size: 1.2rem;
            text-align: center;
            color: #000;
        }

        #scoreboard p {
            margin: 1px 0;
        }

        #githubButtonContainer {
            position: fixed;
            Top: 20px;
            left: 90%;
            transform: translateX(-50%);
            text-align: center;
        }

        #githubButton {
            display: inline-block;
            padding: 10px 20px;
            font-size: 1rem;
            background-color: #24292e;
            color: #fff;
            text-decoration: none;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s, transform 0.3s;
        }

        #githubButton:hover {
            background-color: #0366d6;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <h1>Let's play a game</h1>
    <canvas id="gameCanvas"></canvas>
    <button id="restartButton" onclick="resetGame()">Restart</button>
    <div id="scoreboard">
        <p>X Wins: <span id="xWins">0</span></p>
        <p>O Wins: <span id="oWins">0</span></p>
        <p>Draws: <span id="draws">0</span></p>
    </div>

    <!-- Include Socket.IO library -->
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Initialize Socket.IO
        const socket = io();

        // Game variables
        let canvas, ctx, squareSize, rows = 3, cols = 3;
        let board = Array(rows).fill(null).map(() => Array(cols).fill(null));
        let currentPlayer = 'X', hoveredBox = null;
        let xWins = 0, oWins = 0, draws = 0;

        // Load sound effects
        const clickSound = new Audio('./sounds/mouse-click.mp3');
        const winSound = new Audio('./sounds/success-fanfare-trumpets.mp3');
        const drawSound = new Audio('./sounds/draw-sword1.mp3');

        // Initialize the game on window load
        window.onload = () => {
            socket.emit('test', 'Canvas created');
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            resizeCanvas();
            drawGrid();

            // Add event listeners for user interactions
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseout', handleMouseOut);
            window.addEventListener('resize', resizeCanvas);
        };

        // Draw the game grid
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#4caf50';
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    ctx.fillRect(col * squareSize, row * squareSize, squareSize, squareSize);
                }
            }

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            for (let row = 0; row <= rows; row++) {
                ctx.beginPath();
                ctx.moveTo(0, row * squareSize);
                ctx.lineTo(cols * squareSize, row * squareSize);
                ctx.stroke();
            }
            for (let col = 0; col <= cols; col++) {
                ctx.beginPath();
                ctx.moveTo(col * squareSize, 0);
                ctx.lineTo(col * squareSize, rows * squareSize);
                ctx.stroke();
            }
        }

        // Handle canvas click events
        function handleCanvasClick(event) {
            clickSound.play();
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const clickedCol = Math.floor(x / squareSize);
            const clickedRow = Math.floor(y / squareSize);

            if (clickedCol >= 0 && clickedCol < cols && clickedRow >= 0 && clickedRow < rows) {
                if (board[clickedRow][clickedCol] === null) {
                    board[clickedRow][clickedCol] = currentPlayer;
                    drawMark(clickedRow, clickedCol, currentPlayer);
                    if (checkWin(clickedRow, clickedCol)) {
                        winSound.play();
                        setTimeout(() => {
                            alert(`${currentPlayer} wins!`);
                            updateScoreboard();
                            resetGame();
                        }, 100);
                    } else if (checkDraw()) {
                        drawSound.play();
                        setTimeout(() => {
                            alert("It's a draw!");
                            updateScoreboard(true);
                            resetGame();
                        }, 100);
                    } else {
                        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                    }
                }
            }
        }

        // Handle mouse move events
        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const hoveredCol = Math.floor(x / squareSize);
            const hoveredRow = Math.floor(y / squareSize);

            if (hoveredCol >= 0 && hoveredCol < cols && hoveredRow >= 0 && hoveredRow < rows) {
                if (board[hoveredRow][hoveredCol] === null) {
                    if (hoveredBox === null || hoveredBox.row !== hoveredRow || hoveredBox.col !== hoveredCol) {
                        if (hoveredBox !== null) {
                            clearGlow(hoveredBox.row, hoveredBox.col);
                        }
                        hoveredBox = { row: hoveredRow, col: hoveredCol };
                        drawGlow(hoveredRow, hoveredCol);
                    }
                } else {
                    if (hoveredBox !== null) {
                        clearGlow(hoveredBox.row, hoveredBox.col);
                        hoveredBox = null;
                    }
                }
            } else {
                if (hoveredBox !== null) {
                    clearGlow(hoveredBox.row, hoveredBox.col);
                    hoveredBox = null;
                }
            }
        }

        // Handle mouse out events
        function handleMouseOut() {
            if (hoveredBox !== null) {
                clearGlow(hoveredBox.row, hoveredBox.col);
                hoveredBox = null;
            }
        }

        // Draw a glowing effect on the hovered box
        function drawGlow(row, col) {
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 5;
            ctx.strokeRect(col * squareSize, row * squareSize, squareSize, squareSize);
        }

        // Clear the glowing effect from the box
        function clearGlow(row, col) {
            ctx.clearRect(col * squareSize, row * squareSize, squareSize, squareSize);
            ctx.fillStyle = '#4caf50';
            ctx.fillRect(col * squareSize, row * squareSize, squareSize, squareSize);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(col * squareSize, row * squareSize, squareSize, squareSize);
            if (board[row][col] !== null) {
                drawMark(row, col, board[row][col]);
            }
        }

        // Draw the player's mark on the board
        function drawMark(row, col, player) {
            ctx.fillStyle = '#fff';
            ctx.fillRect(col * squareSize, row * squareSize, squareSize, squareSize);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(col * squareSize, row * squareSize, squareSize, squareSize);

            ctx.fillStyle = '#000';
            ctx.font = `${squareSize * 0.8}px 'Comic Sans MS', cursive, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(player, col * squareSize + squareSize / 2, row * squareSize + squareSize / 2);
        }

        // Check if the current player has won
        function checkWin(row, col) {
            const player = board[row][col];
            
            // Check row
            if (board[row].every(cell => cell === player)) {
                setTimeout(() => drawWinningLine(row, 0, row, cols - 1), 0);
                return true;
            }

            // Check column
            if (board.every(r => r[col] === player)) {
                setTimeout(() => drawWinningLine(0, col, rows - 1, col), 0);
                return true;
            }

            // Check diagonal
            if (row === col && board.every((r, i) => r[i] === player)) {
                setTimeout(() => drawWinningLine(0, 0, rows - 1, cols - 1), 0);
                return true;
            }

            // Check anti-diagonal
            if (row + col === cols - 1 && board.every((r, i) => r[cols - 1 - i] === player)) {
                setTimeout(() => drawWinningLine(0, cols - 1, rows - 1, 0), 0);
                return true;
            }

            return false;
        }

        // Draw a line indicating the winning combination
        function drawWinningLine(startRow, startCol, endRow, endCol) {
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(startCol * squareSize + squareSize / 2, startRow * squareSize + squareSize / 2);
            ctx.lineTo(endCol * squareSize + squareSize / 2, endRow * squareSize + squareSize / 2);
            ctx.stroke();
        }

        // Check if the game is a draw
        function checkDraw() {
            return board.flat().every(cell => cell !== null);
        }

        // Reset the game board
        function resetGame() {
            board = Array(rows).fill(null).map(() => Array(cols).fill(null));
            currentPlayer = 'X';
            drawGrid();
            document.getElementById('restartButton').style.display = 'none';
        }

        // Update the scoreboard with the current game results
        function updateScoreboard(isDraw = false) {
            if (isDraw) {
                draws++;
                document.getElementById('draws').textContent = draws;
            } else {
                if (currentPlayer === 'X') {
                    xWins++;
                    document.getElementById('xWins').textContent = xWins;
                } else {
                    oWins++;
                    document.getElementById('oWins').textContent = oWins;
                }
            }
        }

        // Resize the canvas and redraw the grid and marks
        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            squareSize = canvas.width / cols;
            drawGrid();
            board.forEach((row, rIndex) => {
                row.forEach((cell, cIndex) => {
                    if (cell !== null) {
                        drawMark(rIndex, cIndex, cell);
                    }
                });
            });
        }
    </script>

<div id="githubButtonContainer">
    <a id="githubButton" href="https://github.com/Stevecmd/Tic-Tac-Triumph/" target="_blank">Check out our GitHub!</a>
</div>

</body>
</html>